# zk-llvm-ir
Llvm-ir to zk-circuit converter proof of concept. 

## Repository structure
The repository consists of several folders, the structure of which should provide a good explanation of what the project intends to do.

### stylus-contract
A simple contract written using the [cargo-stylus](https://github.com/OffchainLabs/cargo-stylus) ecosystem.
The contract has one [function](./stylus-contract/src/lib.rs).

```rust
pub fn mock_check(&self, secret: u32, flag: bool) -> bool {
        let mut result = secret;
        // using `wrapping_mul` and `unchecked_add` simplifies the IR
        if flag {
            result = result.wrapping_mul(3);
        } else {
            if result == 900 {
                return true;
            } else {
                result = result.wrapping_add(100);
                if result == 101 {
                    result = 102
                }
            }
        }
        if secret == 800 {
            return true;
        }

        if secret == 800 {
            return false;
        }
        result == 102
    }
```
This is the function whose IR we'll analyze. Notice how there are a couple of different possible input pairs that return `true`. They're saved in the 'circuit/true_inputs.json` file.

### analysis
A Rust binary that takes the IR dumped from the stylus contract and transpiles it to a [circom](https://docs.circom.io/) circuit.
It supports if-else statements. The IRs CFG is sorted topologically, and the store instructions that affect branch-shared data are done conditionally based on the corresponding branches' conditions. (Bounded) loops are not supported for now.

### circuit
This is the [circom](https://docs.circom.io/) project that is the product of the IR analysis.

## Running the modules

Running the project is a multi-step process. Most of the steps are saved in the repo, and running the first steps may be skipped if wished so.

### Dependencies

Running the project will require several dependencies. 

- [Rust](https://www.rust-lang.org/) - `stylus-contract` and `analysis` are both Rust projects.
- [cargo-stylus](https://github.com/OffchainLabs/cargo-stylus?tab=readme-ov-file#installing-with-cargo) - contract framework written in Rust required for `stylus-contract`
- [LLVM](https://llvm.org/docs/GettingStarted.html) - some of the dependencies in `analysis` rely on the system installation of LLVM (version 18).
- [opt](https://llvm.org/docs/CommandGuide/opt.html) - LLVM optimizer. Used to strip some debug info from the IR. Should be a part of your LLVM installation.
- [circom](https://docs.circom.io/getting-started/installation/) - circuit compiler required to compile the code generated by `analysis`. Make sure to install all the dependencies listed on the installation page.

### Dumping the IR

To dump the IR of the `mock_check` function:
```bash
cd stylus-contract
./dump_ir.sh
```
This will produce the `stylus_contract.ll` file with the LLVM IR for your project in the current directory.

### Generating the circom code 

Execute the following from the root directory:
```bash
cd analysis
cargo run -- --ir ../stylus-contract/stylus_contract.ll -f mock_check -o ../circuit/mock_check.circom
```
This will take the previously dumped IR, find a mock_check function, and generate the circom code for it in the `circuit` directory.

### Compiling the circuit

Execute the following from the root directory:
```bash
cd circuit
circom mock_check.circom --r1cs --wasm --sym
```

### Generating the witness

If you want to read more about what is the *witness* I refer you to [here](https://docs.circom.io/getting-started/computing-the-witness/#what-is-a-witness).

The inputs to the circuit are saved in the `circuit/input.json` file.

While in the `circuit` directory execute the following:
```bash
cd mock_check_js
node generate_witness.js mock_check.wasm ../input.json witness.wtns 
```

### Proving the circuit

This section closely follows the steps described [here](https://docs.circom.io/getting-started/proving-circuits/).

Powers of tau (assuming `circuit` directory):

```bash
snarkjs powersoftau new bn128 12 pot12_0000.ptau -v
snarkjs powersoftau contribute pot12_0000.ptau pot12_0001.ptau --name="first" -v
```

Circuit-specific part:

```bash
snarkjs powersoftau prepare phase2 pot12_0001.ptau pot12_final.ptau -v
snarkjs groth16 setup mock_check.r1cs pot12_final.ptau mock_check_0000.zkey
snarkjs zkey contribute mock_check_0000.zkey mock_check_0001.zkey --name="somename" -v
snarkjs zkey export verificationkey mock_check_0001.zkey verification_key.json
```

Generating a proof

```bash
snarkjs groth16 prove mock_check_0001.zkey mock_check_js/witness.wtns proof.json public.json
```

This will produce a `public.json` file which should look like this (`1` stands for `true`):

```json
[
 "1"
]
```

It means that our original `mock_hash` function would indeed have produced `true` - meaning that we know a number satisfying the constraints imposed by the logic (simple in our case, but could be a pre-image of a cryptographically secure hash function). With the generated circuit we are able to prove that .


### Smart contract verification

Generating the Solidity verifier:

```bash
snarkjs zkey export solidityverifier mock_check_0001.zkey verifier.sol
```
This produces a solidity contract `verifier.sol` that can be deployed and tested.
The contract has one method:
```
function verifyProof(uint[2] calldata _pA, uint[2][2] calldata _pB, uint[2] calldata _pC, uint[2] calldata _pubSignals) public view returns (bool) { .. }
```
This method takes the encoded zk-proof and outputs a boolean indicating its correctness.

Generate the calldata using this function:

```bash
snarkjs generatecall
```

## Deployed contract

The example contract (`verifier.sol`), produced with the above steps (but for a simpler `mock_check` function), is deployed to testnet and can be viewed here:

https://sepolia.etherscan.io/address/0x4c37bed9ce2d4318452bd996ee6caa6065dd7c44#code

You can check the behaviour of the contract locally or in [Remix](https://remix-project.org/?lang=en) or run the following command (make sure to have all the required API keys):

```bash
cast call 0x4c37bed9ce2d4318452bd996ee6caa6065dd7c44 $(cat calldata.txt) --rpc-url https://eth-sepolia.blastapi.io/your-key # or different rpc
```



